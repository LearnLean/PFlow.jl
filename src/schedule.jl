# --------------------------------------------
# this file is part of PFlow.jl
# it implements the scheduling
# --------------------------------------------
# author: Paul Bayer, Paul.Bayer@gleichsam.de
# --------------------------------------------
# license: MIT
# --------------------------------------------

"""
    sched    = Channel(0)

internal scheduling channel. The product scheduling task is waiting with `take!`
for notifications on this channel in order to wake up. A client task executes a
`put!` on `sched` in order to activate the `scheduler` process. This is done
by `call_scheduler()`.
""" 
sched    = Channel(0)

"""
    create_mps(plan::Plan, order::Orders) :: Products

return a master production schedule (MPS) for a production system.

# Arguments
- `plan::Plan`: array of planned product codes
- `order::Orders`: order dictionary
- `leveled::Bool=true`: should the MPS be Heijunka-leveled?
"""
function create_mps(plan::Plan, order::Orders, leveled::Bool=true) :: Products
    mps = Products()
    demand = [p.demand for p ∈ plan]
    if leveled
        mix = Int.(round.(demand./minimum(demand))) # calculate the mix
        index = [1 for i ∈ demand]                  # create an index for the orders
        while length(mps) < sum(demand)
            for i ∈ 1:length(plan)
                k = min(index[i]+mix[i]-1, demand[i])
                for j ∈ index[i]:k
                    pl = plan[i]
                    item = pl.item_offset+j
                    jobs = deepcopy(order[pl.order])
                    for job ∈ jobs
                        job.item = item
                    end
                    p = Product(pl.code, item, pl.name, pl.description,
                                pl.order, jobs)
                    push!(mps, p)
                end
                index[i] = k + 1
            end # for
        end # while
    else
        for pl ∈ plan
            for j ∈ 1:pl.demand
                item = pl.item_offset+j
                jobs = deepcopy(order[pl.order])
                for job ∈ jobs
                    job.item = item
                end
                p = Product(pl.code, item, pl.name, pl.description,
                            pl.order, jobs)
                push!(mps, p)
            end
        end
    end
    mps
end

"""
    scheduler(sim::DES, wus::Workunits)

Cycle through all work units in `wus`, look for finished jobs (in `wu.output`)
and move them to the next free work unit.
"""
function scheduler(sim::DES, wus::Workunits)
    timer = sim.time
    global sched
    while true
        try
            for wu ∈ values(wus)
                while !isempty(wu.output)                  # look for ready products
                    p = front(wu.output)                   # get first product
                    if p.pjob < length(p.jobs)             # are there yet open jobs?
                        job = p.jobs[p.pjob+1]
                        nextw = ""
                        len = 1e6
                        for target ∈ job.wus               # look for possible targets
                            if !isfull(wus[target].input)  # get shortest input queue
                                if length(wus[target].input) < len
                                    len = length(wus[target].input)
                                    nextw = target
                                end
                            end
                        end
                        if nextw ≠ ""                      # found something
                            (p, timer) = dequeue!(wu.output)
                            enqueue!(wus[nextw].input, p)
                            p.pjob += 1                    # set pointer to next job
                            p.jobs[p.pjob].wu = nextw      # trace workunit
                        else
                            break                          # cannot schedule further
                        end # if nextw
                    else                                   # product has no open jobs
                        (p, timer) = dequeue!(wu.output)
                        p.status = FINISHED
                        enqueue!(wus["OUT"].input, p)
                    end
                end # if !isempty
            end # for wu
            take!(sched) # wait for requests
        catch ex
            if isa(ex, SimException) && ex.cause == FINISHED
                break
            else
                rethrow(ex)
            end
        end
    end # while true
end # function


"""
    source(sim::DES, wu::Workunit, mps::Products)

release products into a production system

# Arguments
- `sim::DES`: DES variable
- `wu::Workunit`: first workunit in `wus::Array{Workunit, 1}` which the
                  scheduler gets for operation. Here only `wu.output` is used.
- `mps::Products`: the products generated by `create_mps`
"""
function source(sim::DES, wu::Workunit, mps::Products)
    while length(mps) > 0
        try
            p = shift!(mps)
            p.start_time = now(sim)
            enqueue!(wu.output, p)
            call_scheduler()
        catch ex
            if isa(ex, SimException) && ex.cause == FINISHED
                break
            else
                rethrow(ex)
            end
        end
    end
end


"""
    sink(sim::DES, wu::Workunit, output::Products)

collect finished products from a production system

# Arguments
- `sim::DES`: DES variable
- `wu::Workunit`: **last** workunit in `wus::Workunits` which the
                  scheduler gets for operation. Here only `wu.input` is used.
- `output::Products`: the finished products, normally empty when
                      calling this procedure
"""
function sink(sim::DES, wu::Workunit, output::Products)
    timer = sim.time
    while true
        try
            (p, timer) = dequeue!(wu.input)
            p.end_time = now(sim)
            push!(output, p)
        catch ex
            if isa(ex, SimException) && ex.cause == FINISHED
                break
            else
                rethrow(ex)
            end
        end
    end
end

"""
    start_scheduling(sim::DES, wus::Workunits, mps::Products, output::Products)

get the MPS and a production system and start source, sink and scheduling
"""
function start_scheduling(sim::DES, wus::Workunits, mps::Products, output::Products)
    w1 = Workunit("IN", "Input", STORE,
                  PFQueue("DUMMY", sim, 1), Products(), PFQueue("INPUT", sim, 10),
                  1000, 0, 0, 0, 0.0, 0.0, PFlog[])
    wus["IN"] = w1
    s1 = @async source(sim, w1, mps)
    w2 = Workunit("OUT", "Output", STORE,
                PFQueue("OUTPUT", sim, 10), Products(), PFQueue("DUMMY", sim, 1),
                1000, 0, 0, 0, 0.0, 0.0, PFlog[])
    wus["OUT"] = w2
    s2 = @async sink(sim, w2, output)
    s3 = @async scheduler(sim, wus)
    register(sim, [s1, s2, s3])
end


"""
    call_scheduler()

call the scheduler
"""
call_scheduler() = put!(sched, 1)
